<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Arcade Shooter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #gameUI {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 200;
        }
        .game-button {
            padding: 15px 30px;
            font-size: 1.2em;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
        }
        #gameOver, #victory {
            display: none;
        }
        
        @keyframes wavePulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="menu">
        <h1>3D Arcade Shooter</h1>
        <p id="characterInfo">Loading character...</p>
        <div style="color: #ccc; margin: 20px 0; text-align: left; display: inline-block;">
            <h3>Controls:</h3>
            <p><strong>W/Z:</strong> Move Forward</p>
            <p><strong>S:</strong> Move Backward</p>
            <p><strong>A/Q:</strong> Move Left</p>
            <p><strong>D:</strong> Move Right</p>
            <p><strong>Mouse:</strong> Look Around (Camera Control)</p>
            <p><strong>Mouse Click:</strong> Shoot</p>
            <p><strong>Y:</strong> Toggle Camera Lock</p>
            <p><strong>ESC:</strong> Unlock Mouse Pointer</p>
            <p><strong>Space:</strong> Special Ability</p>
        </div>
        <button class="game-button" onclick="startGame()">Start Game</button>
        <button class="game-button" onclick="showCharacterSelection()" style="background: #2196F3; margin-left: 10px;">Choose Character</button>
    </div>
    
    <!-- Character Selection Modal -->
    <div id="characterSelection" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); padding: 30px; border-radius: 15px; color: white; z-index: 300; max-width: 800px;">
        <h2>Choose Your Character</h2>
        <div id="characterGrid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin: 20px 0;">
            <!-- Characters will be populated here -->
        </div>
        <button class="game-button" onclick="hideCharacterSelection()">Back</button>
    </div>
    
    <div id="gameUI" style="display: none;">
        <div>Health: <span id="health">100</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>Wave: <span id="wave">1</span></div>
        <div>Enemies: <span id="enemies">3</span></div>
        <div>Total Kills: <span id="totalKills">0</span></div>
        <div>Ammo: <span id="ammo">30</span></div>
    </div>
    
    <div id="gameOver" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; z-index: 200;">
        <h1>Game Over!</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="game-button" onclick="location.reload()">Play Again</button>
    </div>
    
    <div id="victory" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; text-align: center; z-index: 200;">
        <h1>Victory!</h1>
        <p>Final Score: <span id="victoryScore">0</span></p>
        <button class="game-button" onclick="location.reload()">Play Again</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let player, enemies = [], bullets = [];
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let health = 100, score = 0, ammo = 30;
        let gameRunning = false;
        let clock = new THREE.Clock();
        let animationId = null;
        let cameraAngle = 0; // Camera rotation angle
        let cameraDistance = 15; // Distance from player
        let cameraHeight = 10; // Height above player
        let selectedCharacter = null;
        let specialAbilityActive = false;
        let specialAbilityCooldown = 0;
        let mouseX = 0, mouseY = 0;
        let isFlying = false; // Dragon flight mode
        let isInvisible = false; // Ninja invisibility
        let hasShield = false; // Warrior shield
        let turretActive = false; // Robot turret
        let shieldMesh = null; // Shield visual
        let turretMesh = null; // Turret visual
        let cameraLocked = false; // Camera lock state
        let mouseCenterX = 0, mouseCenterY = 0; // Mouse center position
        let crosshair = null; // Crosshair mesh
        let isMouseDown = false; // Mouse button state
        let autoFire = false; // Auto-fire state
        let lastFireTime = 0; // Last fire time for auto-fire
        let environment = []; // Environment objects like trees
        let raycaster = new THREE.Raycaster(); // For crosshair targeting
        let mouseVector = new THREE.Vector2(); // For mouse position
        let freeCameraMode = false; // Toggle for free camera mode
        let cameraPitch = 0; // Vertical camera angle (up/down)
        let cameraYaw = 0; // Horizontal camera angle (left/right)
        let thirdPersonMode = true; // Always use third-person camera like Minecraft/Fortnite
        
        // Wave system variables
        let currentWave = 1;
        let enemiesPerWave = 3;
        let enemiesKilledThisWave = 0;
        let waveInProgress = false;
        let waveSpawnDelay = 0;
        let waveAnnouncementTime = 0;
        let totalEnemiesKilled = 0;
        let waveBonusScore = 0;
        let enemySpawnPositions = [
            { x: -40, z: -40 }, { x: 0, z: -45 }, { x: 40, z: -40 },
            { x: -45, z: 0 }, { x: 45, z: 0 },
            { x: -40, z: 40 }, { x: 0, z: 45 }, { x: 40, z: 40 }
        ];
        
        const characterStats = {
            warrior: { health: 120, speed: 4, damage: 25, color: 0x4CAF50, specialAbility: 'shield' },
            ninja: { health: 90, speed: 5, damage: 20, color: 0x2196F3, specialAbility: 'invisibility' },
            mage: { health: 80, speed: 3, damage: 30, color: 0xff9800, specialAbility: 'fireball' },
            robot: { health: 150, speed: 3, damage: 25, color: 0x9c27b0, specialAbility: 'turret' },
            alien: { health: 100, speed: 4, damage: 20, color: 0x8bc34a, specialAbility: 'teleport' },
            dragon: { health: 200, speed: 2, damage: 35, color: 0xffeb3b, specialAbility: 'flight' }
        };
        
        // Enemy types for wave system
        const enemyTypes = {
            basic: { health: 60, speed: 0.05, damage: 15, color: 0xf44336, size: 0.8, score: 100 },
            fast: { health: 40, speed: 0.08, damage: 10, color: 0xff9800, size: 0.6, score: 150 },
            tank: { health: 100, speed: 0.03, damage: 20, color: 0x795548, size: 1.2, score: 200 },
            sniper: { health: 50, speed: 0.04, damage: 25, color: 0x9c27b0, size: 0.7, score: 175 }
        };
        
        function init() {
            // Load selected character
            loadSelectedCharacter();
            
            // Initialize scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
            console.log('Scene created');
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            console.log('Camera created');
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x87CEEB); // Sky blue background
            renderer.gammaFactor = 2.2; // Better color perception
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5;
            document.body.appendChild(renderer.domElement);
            console.log('WebGL renderer created');
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(100, 20, 0x444444, 0x222222);
            scene.add(gridHelper);
            
            // Create environment
            createEnvironment();
            
            // Create crosshair
            createCrosshair();
            
            // Player with character stats
            createPlayer();
            
            // Create enemies
            createEnemies();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onMouseClick);
            
            // Pointer lock events
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('mozpointerlockchange', onPointerLockChange);
            document.addEventListener('webkitpointerlockchange', onPointerLockChange);
            
            console.log('Event listeners added');
            
            console.log('=== INITIALIZATION COMPLETE ===');
            console.log('Total scene objects:', scene.children.length);
            
            // Game will start when startGame() is called
        }
        
        function loadSelectedCharacter() {
            const savedCharacter = localStorage.getItem('selectedCharacter');
            if (savedCharacter) {
                selectedCharacter = JSON.parse(savedCharacter);
                health = selectedCharacter.health;
                
                // Update menu with character info
                const characterInfo = document.getElementById('characterInfo');
                characterInfo.textContent = `Custom Character - Health: ${health}, Speed: ${selectedCharacter.speed}, Damage: ${selectedCharacter.damage}`;
            } else {
                // Default character if none selected
                selectedCharacter = {
                    health: 100,
                    speed: 4,
                    damage: 20,
                    color: 0x4CAF50,
                    specialAbility: 'none'
                };
                document.getElementById('characterInfo').textContent = 'Default Character';
            }
        }
        
        function createEnvironment() {
            console.log('Creating environment...');
            console.log('Current scene objects count:', scene.children.length);
            
            // Create grass ground texture
            const grassGeometry = new THREE.PlaneGeometry(100, 100);
            const grassMaterial = new THREE.MeshLambertMaterial({ color: 0x3a5f3b });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.receiveShadow = true;
            scene.add(grass);
            console.log('Grass added to scene');
            console.log('Scene objects after grass:', scene.children.length);
            
            // Create map boundary walls
            createBoundaryWalls();
            console.log('Boundary walls created');
            console.log('Scene objects after walls:', scene.children.length);
            
            // Create trees
            createTrees();
            console.log('Environment creation complete. Total objects:', scene.children.length);
        }
        
        function createBoundaryWalls() {
            const wallHeight = 10;
            const wallThickness = 1;
            const wallColor = 0x8B4513; // Castle wall color
            
            // Create wall material
            const wallMaterial = new THREE.MeshLambertMaterial({ color: wallColor });
            
            // North wall
            const northWallGeometry = new THREE.BoxGeometry(100, wallHeight, wallThickness);
            const northWall = new THREE.Mesh(northWallGeometry, wallMaterial);
            northWall.position.set(0, wallHeight / 2, -50);
            northWall.castShadow = true;
            northWall.receiveShadow = true;
            scene.add(northWall);
            
            // South wall
            const southWallGeometry = new THREE.BoxGeometry(100, wallHeight, wallThickness);
            const southWall = new THREE.Mesh(southWallGeometry, wallMaterial);
            southWall.position.set(0, wallHeight / 2, 50);
            southWall.castShadow = true;
            southWall.receiveShadow = true;
            scene.add(southWall);
            
            // East wall
            const eastWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, 100);
            const eastWall = new THREE.Mesh(eastWallGeometry, wallMaterial);
            eastWall.position.set(50, wallHeight / 2, 0);
            eastWall.castShadow = true;
            eastWall.receiveShadow = true;
            scene.add(eastWall);
            
            // West wall
            const westWallGeometry = new THREE.BoxGeometry(wallThickness, wallHeight, 100);
            const westWall = new THREE.Mesh(westWallGeometry, wallMaterial);
            westWall.position.set(-50, wallHeight / 2, 0);
            westWall.castShadow = true;
            westWall.receiveShadow = true;
            scene.add(westWall);
            
            // Add walls to environment array for collision detection
            environment.push(northWall, southWall, eastWall, westWall);
        }
        
        function createTrees() {
            console.log('Creating trees...');
            const treePositions = [
                { x: -30, z: -30 }, { x: 20, z: -20 }, { x: -15, z: 25 },
                { x: 35, z: 10 }, { x: -25, z: -10 }, { x: 30, z: 30 },
                { x: 10, z: -35 }, { x: -35, z: 15 }, { x: 40, z: -5 }
            ];
            
            treePositions.forEach((pos, index) => {
                const tree = createTree(pos.x, pos.z);
                if (tree) {
                    environment.push(tree);
                    console.log(`Tree ${index} created and added to scene`);
                } else {
                    console.error(`Failed to create tree ${index}`);
                }
            });
            
            console.log(`Total trees created: ${environment.filter(obj => obj.children && obj.children[0] && obj.children[0].geometry instanceof THREE.CylinderGeometry).length}`);
        }
        
        function createTree(x, z) {
            console.log(`Creating tree at position: x=${x}, z=${z}`);
            
            const treeGroup = new THREE.Group();
            
            // Tree trunk - make it larger and more visible
            const trunkGeometry = new THREE.CylinderGeometry(1, 1, 6); // Increased size
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3; // Raised height
            trunk.castShadow = true;
            treeGroup.add(trunk);
            console.log('Tree trunk created');
            
            // Tree leaves - make them larger and more visible
            const leavesGeometry = new THREE.ConeGeometry(4, 8, 8); // Increased size
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 6; // Raised height
            leaves.castShadow = true;
            treeGroup.add(leaves);
            console.log('Tree leaves created');
            
            // Position tree
            treeGroup.position.set(x, 0, z);
            console.log(`Tree positioned at: x=${x}, z=${z}`);
            
            scene.add(treeGroup);
            console.log('Tree added to scene. Total objects now:', scene.children.length);
            
            // Make tree visible in game
            treeGroup.visible = true;
            
            return treeGroup;
        }
        
        function createCrosshair() {
            // Create crosshair using HTML overlay for screen-center positioning
            const crosshairElement = document.createElement('div');
            crosshairElement.id = 'crosshair';
            crosshairElement.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 20px;
                height: 20px;
                pointer-events: none;
                z-index: 1000;
            `;
            
            // Create crosshair SVG
            crosshairElement.innerHTML = `
                <svg width="20" height="20" style="position: absolute; top: -10px; left: -10px;">
                    <line x1="10" y1="0" x2="10" y2="20" stroke="#00FF00" stroke-width="1"/>
                    <line x1="0" y1="10" x2="20" y2="10" stroke="#00FF00" stroke-width="1"/>
                    <circle cx="10" cy="10" r="1" fill="#FFFFFF"/>
                </svg>
            `;
            
            document.body.appendChild(crosshairElement);
            crosshair = crosshairElement;
        }
        
        function updateCrosshairPosition() {
            // Crosshair is now HTML overlay, always centered - no 3D positioning needed
        }
        
        function createPlayer() {
            // Get character type using the same reliable detection as toggleSpecialAbility
            let characterType = 'default';
            
            // More reliable character detection using multiple properties
            for (const [key, value] of Object.entries(characterStats)) {
                if (value.health === selectedCharacter.health && 
                    value.speed === selectedCharacter.speed && 
                    value.damage === selectedCharacter.damage) {
                    characterType = key;
                    break;
                }
            }
            
            console.log('Creating character type:', characterType, 'Selected character:', selectedCharacter);
            
            let playerGeometry;
            let playerMaterial;
            
            switch(characterType) {
                case 'warrior':
                    // Warrior - Humanoid with armor
                    const warriorGroup = new THREE.Group();
                    
                    // Body
                    const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
                    const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                    body.position.y = 0.6;
                    warriorGroup.add(body);
                    
                    // Head
                    const headGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFDBCB4 });
                    const head = new THREE.Mesh(headGeometry, headMaterial);
                    head.position.y = 1.4;
                    warriorGroup.add(head);
                    
                    // Sword
                    const swordGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.05);
                    const swordMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
                    const sword = new THREE.Mesh(swordGeometry, swordMaterial);
                    sword.position.set(0.6, 1.2, 0);
                    warriorGroup.add(sword);
                    
                    // Shield
                    const shieldGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.05, 8);
                    const shieldMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
                    const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                    shield.position.set(-0.5, 0.8, 0);
                    shield.rotation.z = Math.PI / 2;
                    warriorGroup.add(shield);
                    
                    playerGeometry = warriorGroup;
                    playerMaterial = bodyMaterial;
                    console.log('Warrior model created');
                    break;
                    
                case 'ninja':
                    // Ninja - Sleek, dark figure
                    const ninjaGroup = new THREE.Group();
                    
                    // Body (slim)
                    const ninjaBodyGeometry = new THREE.BoxGeometry(0.4, 1.2, 0.3);
                    const ninjaBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
                    const ninjaBody = new THREE.Mesh(ninjaBodyGeometry, ninjaBodyMaterial);
                    ninjaBody.position.y = 0.6;
                    ninjaGroup.add(ninjaBody);
                    
                    // Head (wrapped)
                    const ninjaHeadGeometry = new THREE.BoxGeometry(0.25, 0.3, 0.25);
                    const ninjaHeadMaterial = new THREE.MeshLambertMaterial({ color: 0x1C1C1C });
                    const ninjaHead = new THREE.Mesh(ninjaHeadGeometry, ninjaHeadMaterial);
                    ninjaHead.position.y = 1.3;
                    ninjaGroup.add(ninjaHead);
                    
                    // Katana
                    const katanaGeometry = new THREE.BoxGeometry(0.05, 1.8, 0.02);
                    const katanaMaterial = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
                    const katana = new THREE.Mesh(katanaGeometry, katanaMaterial);
                    katana.position.set(0.4, 1.5, 0);
                    ninjaGroup.add(katana);
                    
                    playerGeometry = ninjaGroup;
                    playerMaterial = ninjaBodyMaterial;
                    console.log('Ninja model created');
                    break;
                    
                case 'mage':
                    // Mage - Robe and staff
                    const mageGroup = new THREE.Group();
                    
                    // Robe body
                    const mageBodyGeometry = new THREE.ConeGeometry(0.6, 1.8, 8);
                    const mageBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x4B0082 });
                    const mageBody = new THREE.Mesh(mageBodyGeometry, mageBodyMaterial);
                    mageBody.position.y = 0.9;
                    mageGroup.add(mageBody);
                    
                    // Wizard hat
                    const hatGeometry = new THREE.ConeGeometry(0.4, 0.6, 8);
                    const hatMaterial = new THREE.MeshLambertMaterial({ color: 0x2E0854 });
                    const hat = new THREE.Mesh(hatGeometry, hatMaterial);
                    hat.position.y = 1.8;
                    mageGroup.add(hat);
                    
                    // Staff
                    const staffGeometry = new THREE.CylinderGeometry(0.03, 0.03, 2.5, 8);
                    const staffMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const staff = new THREE.Mesh(staffGeometry, staffMaterial);
                    staff.position.set(0.3, 1.5, 0);
                    mageGroup.add(staff);
                    
                    // Crystal on staff
                    const crystalGeometry = new THREE.OctahedronGeometry(0.15);
                    const crystalMaterial = new THREE.MeshLambertMaterial({ color: 0x00FFFF });
                    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                    crystal.position.set(0.3, 2.8, 0);
                    mageGroup.add(crystal);
                    
                    playerGeometry = mageGroup;
                    playerMaterial = mageBodyMaterial;
                    console.log('Mage model created');
                    break;
                    
                case 'robot':
                    // Robot - Mechanical parts
                    const robotGroup = new THREE.Group();
                    
                    // Main body
                    const robotBodyGeometry = new THREE.BoxGeometry(1, 1.5, 0.8);
                    const robotBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x708090 });
                    const robotBody = new THREE.Mesh(robotBodyGeometry, robotBodyMaterial);
                    robotBody.position.y = 0.75;
                    robotGroup.add(robotBody);
                    
                    // Head
                    const robotHeadGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.6);
                    const robotHeadMaterial = new THREE.MeshLambertMaterial({ color: 0x606060 });
                    const robotHead = new THREE.Mesh(robotHeadGeometry, robotHeadMaterial);
                    robotHead.position.y = 1.8;
                    robotGroup.add(robotHead);
                    
                    // Arms
                    const armGeometry = new THREE.BoxGeometry(0.2, 1, 0.2);
                    const armMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                    
                    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                    leftArm.position.set(-0.7, 1.2, 0);
                    robotGroup.add(leftArm);
                    
                    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                    rightArm.position.set(0.7, 1.2, 0);
                    robotGroup.add(rightArm);
                    
                    // Antenna
                    const antennaGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
                    const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
                    const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                    antenna.position.set(0, 2.2, 0);
                    robotGroup.add(antenna);
                    
                    playerGeometry = robotGroup;
                    playerMaterial = robotBodyMaterial;
                    console.log('Robot model created');
                    break;
                    
                case 'alien':
                    // Alien - Non-humanoid shape
                    const alienGroup = new THREE.Group();
                    
                    // Main body (ellipsoid)
                    const alienBodyGeometry = new THREE.SphereGeometry(0.6, 8, 8);
                    const alienBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x00FF00 });
                    const alienBody = new THREE.Mesh(alienBodyGeometry, alienBodyMaterial);
                    alienBody.scale.set(1, 0.8, 1.2);
                    alienBody.position.y = 0.8;
                    alienGroup.add(alienBody);
                    
                    // Large eyes
                    const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
                    const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
                    
                    const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    leftEye.position.set(-0.2, 1.0, 0.5);
                    alienGroup.add(leftEye);
                    
                    const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                    rightEye.position.set(0.2, 1.0, 0.5);
                    alienGroup.add(rightEye);
                    
                    // Tentacles
                    const tentacleGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.8, 6);
                    const tentacleMaterial = new THREE.MeshLambertMaterial({ color: 0x00CC00 });
                    
                    for (let i = 0; i < 4; i++) {
                        const tentacle = new THREE.Mesh(tentacleGeometry, tentacleMaterial);
                        const angle = (i / 4) * Math.PI * 2;
                        tentacle.position.set(Math.cos(angle) * 0.4, 0.2, Math.sin(angle) * 0.4);
                        tentacle.rotation.x = Math.PI / 6;
                        alienGroup.add(tentacle);
                    }
                    
                    playerGeometry = alienGroup;
                    playerMaterial = alienBodyMaterial;
                    console.log('Alien model created');
                    break;
                    
                case 'dragon':
                    // Dragon - Reptilian beast
                    const dragonGroup = new THREE.Group();
                    
                    // Main body
                    const dragonBodyGeometry = new THREE.BoxGeometry(2, 1.2, 3);
                    const dragonBodyMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
                    const dragonBody = new THREE.Mesh(dragonBodyGeometry, dragonBodyMaterial);
                    dragonBody.position.y = 1;
                    dragonGroup.add(dragonBody);
                    
                    // Dragon head
                    const dragonHeadGeometry = new THREE.BoxGeometry(1, 0.8, 1.5);
                    const dragonHeadMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6347 });
                    const dragonHead = new THREE.Mesh(dragonHeadGeometry, dragonHeadMaterial);
                    dragonHead.position.set(0, 1.8, 1.8);
                    dragonGroup.add(dragonHead);
                    
                    // Tail
                    const tailGeometry = new THREE.ConeGeometry(0.3, 2, 8);
                    const tailMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
                    const tail = new THREE.Mesh(tailGeometry, tailMaterial);
                    tail.position.set(0, 0.5, -2.5);
                    tail.rotation.z = Math.PI / 2;
                    dragonGroup.add(tail);
                    
                    // Wings (folded by default)
                    const wingGeometry = new THREE.BoxGeometry(3, 0.1, 1.5);
                    const wingMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFFEB3B, 
                        transparent: true, 
                        opacity: 0.8 
                    });
                    
                    const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    leftWing.position.set(-1.8, 1.2, 0);
                    dragonGroup.add(leftWing);
                    
                    const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    rightWing.position.set(1.8, 1.2, 0);
                    dragonGroup.add(rightWing);
                    
                    playerGeometry = dragonGroup;
                    playerMaterial = dragonBodyMaterial;
                    console.log('Dragon model created');
                    break;
                    
                default:
                    // Default character
                    playerGeometry = new THREE.BoxGeometry(1, 2, 1);
                    playerMaterial = new THREE.MeshLambertMaterial({ color: selectedCharacter.color });
                    console.log('Default model created');
            }
            
            // Create the player mesh/group
            if (playerGeometry instanceof THREE.Group) {
                player = playerGeometry;
            } else {
                player = new THREE.Mesh(playerGeometry, playerMaterial);
            }
            
            player.position.set(0, 1, 10);
            player.castShadow = true;
            
            // Add shadows to all child meshes
            if (player.children) {
                player.children.forEach(child => {
                    child.castShadow = true;
                });
            }
            
            scene.add(player);
            console.log('Player added to scene');
        }
        
        function createEnemies() {
            // Start with first wave
            startWave(1);
        }
        
        function startWave(waveNumber) {
            console.log(`Starting Wave ${waveNumber}`);
            currentWave = waveNumber;
            enemiesKilledThisWave = 0;
            waveInProgress = true;
            waveAnnouncementTime = 180; // 3 seconds at 60fps
            
            // Calculate enemies for this wave
            enemiesPerWave = Math.min(3 + Math.floor(waveNumber / 2), 12); // Max 12 enemies
            
            // Show wave announcement
            showWaveAnnouncement(waveNumber, enemiesPerWave);
            
            // Spawn enemies with delay
            waveSpawnDelay = 60; // 1 second delay before spawning
        }
        
        function spawnWaveEnemies() {
            const enemiesToSpawn = enemiesPerWave;
            
            for (let i = 0; i < enemiesToSpawn; i++) {
                setTimeout(() => {
                    createWaveEnemy(currentWave);
                }, i * 500); // Spawn each enemy with 500ms delay
            }
        }
        
        function createWaveEnemy(waveNumber) {
            // Determine enemy type based on wave
            let enemyType = 'basic';
            const rand = Math.random();
            
            if (waveNumber >= 3 && rand < 0.2) enemyType = 'tank';
            else if (waveNumber >= 2 && rand < 0.3) enemyType = 'fast';
            else if (waveNumber >= 4 && rand < 0.15) enemyType = 'sniper';
            
            const enemyStats = enemyTypes[enemyType];
            
            // Create enemy with appropriate stats
            const enemyGeometry = new THREE.BoxGeometry(enemyStats.size, enemyStats.size * 1.5, enemyStats.size);
            const enemyMaterial = new THREE.MeshLambertMaterial({ color: enemyStats.color });
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            
            // Random spawn position from predefined positions
            const spawnPos = enemySpawnPositions[Math.floor(Math.random() * enemySpawnPositions.length)];
            enemy.position.set(spawnPos.x, enemyStats.size * 0.75, spawnPos.z);
            
            enemy.castShadow = true;
            enemy.health = enemyStats.health + (waveNumber - 1) * 10; // Scale health with wave
            enemy.speed = enemyStats.speed + (waveNumber - 1) * 0.005; // Scale speed with wave
            enemy.shootCooldown = 0;
            enemy.damage = enemyStats.damage;
            enemy.enemyType = enemyType;
            enemy.scoreValue = enemyStats.score;
            
            enemies.push(enemy);
            scene.add(enemy);
            
            console.log(`Spawned ${enemyType} enemy for wave ${waveNumber}`);
        }
        
        function showWaveAnnouncement(waveNumber, enemyCount) {
            // Create or update wave announcement element
            let announcement = document.getElementById('waveAnnouncement');
            if (!announcement) {
                announcement = document.createElement('div');
                announcement.id = 'waveAnnouncement';
                announcement.style.cssText = `
                    position: absolute;
                    top: 30%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: white;
                    font-size: 3em;
                    font-weight: bold;
                    text-align: center;
                    z-index: 500;
                    text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                    animation: wavePulse 2s ease-in-out;
                `;
                document.body.appendChild(announcement);
            }
            
            announcement.innerHTML = `
                <div>WAVE ${waveNumber}</div>
                <div style="font-size: 0.5em; margin-top: 10px;">${enemyCount} ENEMIES APPROACHING</div>
            `;
            announcement.style.display = 'block';
        }
        
        function hideWaveAnnouncement() {
            const announcement = document.getElementById('waveAnnouncement');
            if (announcement) {
                announcement.style.display = 'none';
            }
        }
        
        function checkWaveCompletion() {
            if (waveInProgress && enemies.length === 0) {
                // Wave completed
                waveInProgress = false;
                const waveBonus = currentWave * 50;
                score += waveBonus;
                totalEnemiesKilled += enemiesKilledThisWave;
                
                console.log(`Wave ${currentWave} completed! Bonus: ${waveBonus}`);
                
                // Show completion message briefly
                showWaveCompleted(currentWave, waveBonus);
                
                // Start next wave after delay
                setTimeout(() => {
                    startWave(currentWave + 1);
                }, 3000);
            }
        }
        
        function showWaveCompleted(waveNumber, bonus) {
            let completion = document.getElementById('waveCompleted');
            if (!completion) {
                completion = document.createElement('div');
                completion.id = 'waveCompleted';
                completion.style.cssText = `
                    position: absolute;
                    top: 40%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: #00FF00;
                    font-size: 2em;
                    font-weight: bold;
                    text-align: center;
                    z-index: 500;
                    text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                `;
                document.body.appendChild(completion);
            }
            
            completion.innerHTML = `
                <div>WAVE ${waveNumber} COMPLETE!</div>
                <div style="font-size: 0.6em; margin-top: 10px;">Bonus: +${bonus}</div>
            `;
            completion.style.display = 'block';
            
            setTimeout(() => {
                completion.style.display = 'none';
            }, 2500);
        }
        
        function startGame() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('gameUI').style.display = 'block';
            gameRunning = true;
            
            // Initialize camera angles for third-person view
            cameraYaw = 0;
            cameraPitch = 0;
            console.log('Game started - Camera initialized - Yaw:', cameraYaw, 'Pitch:', cameraPitch);
            
            // Initialize mouse center
            mouseCenterX = window.innerWidth / 2;
            mouseCenterY = window.innerHeight / 2;
            mouseX = mouseCenterX;
            mouseY = mouseCenterY;
            
            // Lock mouse pointer
            document.body.requestPointerLock = document.body.requestPointerLock || 
                                          document.body.mozRequestPointerLock || 
                                          document.body.webkitRequestPointerLock;
            
            if (document.body.requestPointerLock) {
                document.body.requestPointerLock();
            }
            
            animate();
        }
        
        function animate() {
            if (!gameRunning) return;
            
            try {
                requestAnimationFrame(animate);
                
                const delta = clock.getDelta();
                
                // Check if player exists before using it
                if (!player) {
                    console.error('Player not initialized');
                    return;
                }
                
                // Get character type for dragon flight
                const characterType = Object.keys(characterStats).find(key => 
                    JSON.stringify(characterStats[key]) === JSON.stringify(selectedCharacter)
                );
                
                // Update player movement based on camera direction
                const moveSpeed = selectedCharacter.speed * 0.05; // Use character speed
                
                if (moveForward) {
                    player.position.x += moveSpeed * Math.sin(cameraYaw);
                    player.position.z += moveSpeed * Math.cos(cameraYaw);
                }
                if (moveBackward) {
                    player.position.x -= moveSpeed * Math.sin(cameraYaw);
                    player.position.z -= moveSpeed * Math.cos(cameraYaw);
                }
                if (moveLeft) {
                    player.position.x -= moveSpeed * Math.cos(cameraYaw);
                    player.position.z += moveSpeed * Math.sin(cameraYaw);
                }
                if (moveRight) {
                    player.position.x += moveSpeed * Math.cos(cameraYaw);
                    player.position.z -= moveSpeed * Math.sin(cameraYaw);
                }
                
                // Keep player in bounds (only X and Z, not Y when flying)
                player.position.x = Math.max(-45, Math.min(45, player.position.x));
                player.position.z = Math.max(-45, Math.min(45, player.position.z));
                
                // If not flying, keep player on ground
                if (!isFlying && characterType === 'dragon') {
                    player.position.y = 1;
                }
                
                // Third-person camera like Minecraft/Fortnite
                // Camera orbits around player based on yaw and pitch
                const cameraDistance = 15;
                
                // Calculate camera position based on yaw and pitch
                const horizontalDistance = cameraDistance * Math.cos(cameraPitch);
                const verticalDistance = cameraDistance * Math.sin(cameraPitch);
                
                camera.position.x = player.position.x - horizontalDistance * Math.sin(cameraYaw);
                camera.position.y = player.position.y + 5 + verticalDistance; // 5 units above player + vertical offset
                camera.position.z = player.position.z - horizontalDistance * Math.cos(cameraYaw);
                
                // Camera always looks at player
                camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 2, 0))); // Look at player's head
                
                // Debug output occasionally
                if (Math.random() < 0.02) { // Log occasionally to avoid spam
                    console.log('Camera update - Yaw:', cameraYaw, 'Pitch:', cameraPitch, 'Pos:', camera.position);
                }
                
                // Make character face the direction they're moving (not camera direction)
                if (moveForward || moveBackward || moveLeft || moveRight) {
                    let moveAngle = 0;
                    if (moveForward) moveAngle = cameraYaw;
                    if (moveBackward) moveAngle = cameraYaw + Math.PI;
                    if (moveLeft) moveAngle = cameraYaw + Math.PI/2;
                    if (moveRight) moveAngle = cameraYaw - Math.PI/2;
                    
                    // Combine directions for diagonal movement
                    if (moveForward && moveLeft) moveAngle = cameraYaw + Math.PI/4;
                    if (moveForward && moveRight) moveAngle = cameraYaw - Math.PI/4;
                    if (moveBackward && moveLeft) moveAngle = cameraYaw + 3*Math.PI/4;
                    if (moveBackward && moveRight) moveAngle = cameraYaw - 3*Math.PI/4;
                    
                    player.rotation.y = moveAngle;
                }
                
                // Update crosshair position (now HTML overlay, always centered)
                // No update needed - crosshair is fixed to screen center
                
                // Update special ability cooldown
                if (specialAbilityCooldown > 0) {
                    specialAbilityCooldown--;
                }
                
                // Handle auto-fire when mouse is held down
                handleAutoFire();
                
                // Handle wave spawning delays
                if (waveSpawnDelay > 0) {
                    waveSpawnDelay--;
                    if (waveSpawnDelay === 0) {
                        spawnWaveEnemies();
                    }
                }
                
                // Handle wave announcement timing
                if (waveAnnouncementTime > 0) {
                    waveAnnouncementTime--;
                    if (waveAnnouncementTime === 0) {
                        hideWaveAnnouncement();
                    }
                }
                
                // Update enemies
                updateEnemies(delta);
                
                // Update bullets
                updateBullets();
                
                // Check collisions
                checkCollisions();
                
                // Check wave completion
                checkWaveCompletion();
                
                // Update UI
                updateUI();
                
                // Check win/lose conditions
                if (health <= 0) {
                    gameOver();
                    return;
                }
                // Victory is now achieved by surviving waves indefinitely - no traditional victory condition
                
                renderer.render(scene, camera);
            } catch (error) {
                console.error('Animation error:', error);
                gameRunning = false;
                alert('Game error: ' + error.message);
            }
        }
        
        function updateEnemies(delta) {
            enemies.forEach(enemy => {
                // Simple AI - move towards player
                const direction = new THREE.Vector3();
                direction.subVectors(player.position, enemy.position);
                direction.y = 0;
                direction.normalize();
                
                enemy.position.add(direction.multiplyScalar(enemy.speed));
                
                // Shoot at player (only if player is visible)
                if (enemy.shootCooldown <= 0 && !isInvisible) {
                    const bulletDirection = new THREE.Vector3();
                    bulletDirection.subVectors(player.position, enemy.position);
                    bulletDirection.normalize();
                    
                    createEnemyBullet(enemy.position.clone(), bulletDirection, enemy.damage || 15);
                    enemy.shootCooldown = 120;
                    console.log(`${enemy.enemyType || 'enemy'} shooting at visible player`);
                } else if (enemy.shootCooldown <= 0 && isInvisible) {
                    console.log(`${enemy.enemyType || 'enemy'} sees invisible ninja - not shooting`);
                    enemy.shootCooldown = 60; // Shorter cooldown when player is invisible
                }
                enemy.shootCooldown--;
            });
        }
        
        function createEnemyBullet(position, direction, damage) {
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshLambertMaterial({ color: 0xff9800 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            bullet.position.copy(position);
            bullet.velocity = direction.multiplyScalar(0.5);
            bullet.owner = 'enemy';
            bullet.damage = damage;
            bullet.lifetime = 100;
            
            bullets.push(bullet);
            scene.add(bullet);
        }
        
        function createBullet(position, direction, owner) {
            const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMaterial = new THREE.MeshLambertMaterial({ 
                color: owner === 'player' ? 0xffeb3b : 0xff9800 
            });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            bullet.position.copy(position);
            bullet.velocity = direction.multiplyScalar(0.5);
            bullet.owner = owner;
            bullet.damage = owner === 'player' ? selectedCharacter.damage : 15; // Use character damage
            bullet.lifetime = 100;
            
            bullets.push(bullet);
            scene.add(bullet);
        }
        
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                bullet.position.add(bullet.velocity);
                bullet.lifetime--;
                
                // Check collisions with environment
                environment.forEach(env => {
                    if (env !== bullet && bullet.owner === 'player') {
                        const distance = bullet.position.distanceTo(env.position);
                        if (distance < 2) {
                            bullet.dead = true;
                            // Create impact effect
                            createImpactEffect(bullet.position);
                        }
                    }
                });
                
                // Remove bullets that are too old or out of bounds
                if (bullet.lifetime <= 0 || 
                    Math.abs(bullet.position.x) > 50 || 
                    Math.abs(bullet.position.z) > 50) {
                    scene.remove(bullet);
                    return false;
                }
                
                return true;
            });
        }
        
        function createImpactEffect(position) {
            const impactGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const impactMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00, 
                transparent: true, 
                opacity: 0.6 
            });
            const impact = new THREE.Mesh(impactGeometry, impactMaterial);
            impact.position.copy(position);
            scene.add(impact);
            
            // Remove impact effect after animation
            setTimeout(() => {
                scene.remove(impact);
            }, 200);
        }
        
        function checkCollisions() {
            bullets.forEach((bullet, bulletIndex) => {
                if (bullet.owner === 'player') {
                    // Check collision with enemies
                    enemies.forEach((enemy, enemyIndex) => {
                        const distance = bullet.position.distanceTo(enemy.position);
                        if (distance < 1) {
                            enemy.health -= bullet.damage;
                            scene.remove(bullet);
                            bullets.splice(bulletIndex, 1);
                            
                            if (enemy.health <= 0) {
                                scene.remove(enemy);
                                enemies.splice(enemyIndex, 1);
                                score += enemy.scoreValue || 100;
                                enemiesKilledThisWave++;
                                totalEnemiesKilled++;
                            }
                        }
                    });
                } else if (bullet.owner === 'enemy') {
                    // Check collision with player
                    const distance = bullet.position.distanceTo(player.position);
                    if (distance < 1) {
                        health -= bullet.damage;
                        scene.remove(bullet);
                        bullets.splice(bulletIndex, 1);
                    }
                }
            });
        }
        
        function updateUI() {
            document.getElementById('health').textContent = Math.max(0, health);
            document.getElementById('score').textContent = score;
            document.getElementById('wave').textContent = currentWave;
            document.getElementById('enemies').textContent = enemies.length;
            document.getElementById('totalKills').textContent = totalEnemiesKilled;
            document.getElementById('ammo').textContent = ammo;
        }
        
        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function victory() {
            gameRunning = false;
            document.getElementById('victoryScore').textContent = score;
            document.getElementById('victory').style.display = 'block';
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyZ': // Z for forward (French keyboard)
                case 'KeyW': // W for forward (US keyboard)
                    moveForward = true;
                    break;
                case 'KeyS': // S for backward
                    moveBackward = true;
                    break;
                case 'KeyQ': // Q for left (French keyboard)
                case 'KeyA': // A for left (US keyboard)
                    moveLeft = true;
                    break;
                case 'KeyD': // D for right
                    moveRight = true;
                    break;
                case 'Space': // Space for special ability (toggle)
                    toggleSpecialAbility();
                    break;
                case 'KeyY': // Y to toggle camera lock
                    cameraLocked = !cameraLocked;
                    console.log(cameraLocked ? 'Camera Locked' : 'Camera Unlocked');
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyZ':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'KeyQ':
                    moveLeft = false;
                    break;
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }
        
        function toggleSpecialAbility() {
            // Determine character type by matching selectedCharacter with characterStats
            let characterType = 'default';
            
            // More reliable character detection using multiple properties
            for (const [key, value] of Object.entries(characterStats)) {
                if (value.health === selectedCharacter.health && 
                    value.speed === selectedCharacter.speed && 
                    value.damage === selectedCharacter.damage) {
                    characterType = key;
                    break;
                }
            }
            
            console.log('Character type detected:', characterType, 'Selected character:', selectedCharacter);
            
            const ability = characterStats[characterType]?.specialAbility || 'none';
            
            console.log('Attempting ability:', ability, 'for character type:', characterType);
            
            switch(ability) {
                case 'flight': // Dragon
                    specialAbilityActive = !specialAbilityActive;
                    isFlying = !isFlying;
                    
                    if (isFlying) {
                        // Start flying
                        player.position.y = 10;
                        selectedCharacter.speed = 8;
                        
                        // Create wing effect
                        const wingGeometry = new THREE.BoxGeometry(4, 0.1, 2);
                        const wingMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xffeb3b, 
                            transparent: true, 
                            opacity: 0.7 
                        });
                        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                        leftWing.position.set(-2, 0, 0);
                        player.add(leftWing);
                        
                        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                        rightWing.position.set(2, 0, 0);
                        player.add(rightWing);
                        
                        console.log(' Dragon prend son envol!');
                    } else {
                        // Stop flying
                        player.position.y = 1;
                        selectedCharacter.speed = 2;
                        
                        // Remove wings
                        while(player.children.length > 0) {
                            player.remove(player.children[0]);
                        }
                        
                        console.log(' Dragon atterrit!');
                    }
                    break;
                    
                case 'invisibility': // Ninja
                    specialAbilityActive = !specialAbilityActive;
                    isInvisible = !isInvisible;
                    
                    if (isInvisible) {
                        player.material = new THREE.MeshBasicMaterial({ 
                            color: 0x2F4F4F, 
                            transparent: true, 
                            opacity: 0.3 
                        });
                        console.log(' Ninja devient invisible!');
                    } else {
                        player.material = new THREE.MeshLambertMaterial({ color: 0x2F4F4F });
                        console.log(' Ninja redevient visible!');
                    }
                    break;
                    
                case 'shield': // Warrior
                    specialAbilityActive = !specialAbilityActive;
                    hasShield = !hasShield;
                    
                    if (hasShield) {
                        // Create shield visual
                        const shieldGeometry = new THREE.SphereGeometry(3, 16, 16);
                        const shieldMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x00BFFF, 
                            transparent: true, 
                            opacity: 0.3 
                        });
                        shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
                        player.add(shieldMesh);
                        console.log(' Warrior active son bouclier!');
                    } else {
                        // Remove shield
                        if (shieldMesh) {
                            player.remove(shieldMesh);
                            shieldMesh = null;
                        }
                        console.log(' Warrior dsactive son bouclier!');
                    }
                    break;
                    
                case 'turret': // Robot
                    specialAbilityActive = !specialAbilityActive;
                    turretActive = !turretActive;
                    
                    if (turretActive) {
                        // Create turret visual
                        const turretGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
                        const turretMaterial = new THREE.MeshLambertMaterial({ color: 0x808080 });
                        turretMesh = new THREE.Mesh(turretGeometry, turretMaterial);
                        turretMesh.position.set(2, 1, 0);
                        player.add(turretMesh);
                        console.log(' Robot dploie une tourelle!');
                    } else {
                        // Remove turret
                        if (turretMesh) {
                            player.remove(turretMesh);
                            turretMesh = null;
                        }
                        console.log(' Robot range sa tourelle!');
                    }
                    break;
                    
                case 'teleport': // Alien
                    if (!specialAbilityActive) {
                        // Teleport to random location
                        const teleportX = (Math.random() - 0.5) * 40;
                        const teleportZ = (Math.random() - 0.5) * 40;
                        
                        // Create teleport effect
                        const effectGeometry = new THREE.SphereGeometry(3, 16, 16);
                        const effectMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0x00FF00, 
                            transparent: true, 
                            opacity: 0.5 
                        });
                        const effect = new THREE.Mesh(effectGeometry, effectMaterial);
                        effect.position.copy(player.position);
                        scene.add(effect);
                        
                        // Teleport player
                        player.position.set(teleportX, 1, teleportZ);
                        
                        // Create arrival effect
                        const arrivalEffect = new THREE.Mesh(effectGeometry, effectMaterial);
                        arrivalEffect.position.copy(player.position);
                        scene.add(arrivalEffect);
                        
                        // Remove effects after delay
                        setTimeout(() => {
                            scene.remove(effect);
                            scene.remove(arrivalEffect);
                        }, 1000);
                        
                        console.log(' Alien se tlporte!');
                    }
                    // Teleport is instant, no toggle state
                    break;
                    
                case 'fireball': // Mage
                    if (!specialAbilityActive) {
                        // Create fireball
                        const fireballGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                        const fireballMaterial = new THREE.MeshBasicMaterial({ 
                            color: 0xFF4500,
                            emissive: 0xFF4500
                        });
                        const fireball = new THREE.Mesh(fireballGeometry, fireballMaterial);
                        
                        // Position fireball at player position
                        fireball.position.copy(player.position);
                        fireball.position.y += 1;
                        
                        // Use raycasting for accurate crosshair targeting
                        mouseVector.x = 0; // Center of screen (crosshair is always centered)
                        mouseVector.y = 0;
                        
                        // Update raycaster with camera and mouse position
                        raycaster.setFromCamera(mouseVector, camera);
                        
                        // Calculate fireball direction
                        const direction = new THREE.Vector3();
                        raycaster.ray.direction.normalize();
                        direction.copy(raycaster.ray.direction);
                        
                        scene.add(fireball);
                        
                        // Animate fireball
                        const fireballSpeed = 0.5;
                        const fireballInterval = setInterval(() => {
                            fireball.position.add(direction.clone().multiplyScalar(fireballSpeed));
                            
                            // Check collision with enemies
                            enemies.forEach((enemy, index) => {
                                const distance = fireball.position.distanceTo(enemy.position);
                                if (distance < 2) {
                                    // Damage enemy
                                    enemy.health -= 50;
                                    if (enemy.health <= 0) {
                                        scene.remove(enemy);
                                        enemies.splice(index, 1);
                                        score += 100;
                                    }
                                    
                                    // Create explosion effect
                                    const explosionGeometry = new THREE.SphereGeometry(2, 8, 8);
                                    const explosionMaterial = new THREE.MeshBasicMaterial({ 
                                        color: 0xFF6600, 
                                        transparent: true, 
                                        opacity: 0.7 
                                    });
                                    const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
                                    explosion.position.copy(enemy.position);
                                    scene.add(explosion);
                                    
                                    setTimeout(() => {
                                        scene.remove(explosion);
                                    }, 500);
                                    
                                    // Remove fireball
                                    scene.remove(fireball);
                                    clearInterval(fireballInterval);
                                }
                            });
                            
                            // Remove fireball if out of bounds
                            if (Math.abs(fireball.position.x) > 50 || Math.abs(fireball.position.z) > 50) {
                                scene.remove(fireball);
                                clearInterval(fireballInterval);
                            }
                        }, 16);
                        
                        console.log(' Mage lance une boule de feu!');
                    }
                    // Fireball is instant, no toggle state
                    break;
                    
                default:
                    console.log('Ce personnage n\'a pas de capacit spciale.');
            }
        }
        
        function onPointerLockChange() {
            if (document.pointerLockElement === document.body) {
                console.log('Mouse locked');
            } else {
                console.log('Mouse unlocked');
            }
        }
        
        function onMouseDown(event) {
            isMouseDown = true;
            autoFire = true;
        }
        
        function onMouseUp(event) {
            isMouseDown = false;
            autoFire = false;
        }
        
        function onMouseMove(event) {
            if (document.pointerLockElement === document.body) {
                // Mouse is locked - use movement for camera control like Minecraft/Fortnite
                const sensitivity = 0.002;
                
                // Update camera angles based on mouse movement
                cameraYaw -= (event.movementX || event.mozMovementX || event.webkitMovementX || 0) * sensitivity;
                cameraPitch += (event.movementY || event.mozMovementY || event.webkitMovementY || 0) * sensitivity; // Inverted Y axis
                
                // Clamp pitch to prevent camera flipping
                cameraPitch = Math.max(-Math.PI/3, Math.min(Math.PI/6, cameraPitch)); // Between -60 and 30
                
                // Debug output occasionally
                if (Math.random() < 0.05) { // Log occasionally to avoid spam
                    console.log('Mouse camera - Yaw:', cameraYaw, 'Pitch:', cameraPitch);
                }
            } else {
                // Mouse is not locked - use absolute position
                mouseX = event.clientX;
                mouseY = event.clientY;
            }
        }
        
        function onMouseClick(event) {
            if (!gameRunning || ammo <= 0) return;
            
            // Use raycasting from screen center (crosshair position)
            mouseVector.x = 0; // Center of screen (crosshair is always centered)
            mouseVector.y = 0;
            
            // Update raycaster with camera and crosshair position
            raycaster.setFromCamera(mouseVector, camera);
            
            // Shooting direction is exactly where crosshair points
            const shootDirection = raycaster.ray.direction.clone();
            shootDirection.normalize();
            
            // Debug output
            console.log('Shooting - Direction:', shootDirection, 'Crosshair raycast from center');
            
            // Create bullet at player position with accurate direction
            const bulletPosition = player.position.clone();
            bulletPosition.y += 1; // Shoot from chest height
            
            createBullet(bulletPosition, shootDirection, 'player');
        }
        
        function handleAutoFire() {
            if (!gameRunning || ammo <= 0 || !autoFire) return;
            
            const currentTime = Date.now();
            const fireRate = 100; // Fire every 100ms (10 shots per second)
            
            if (currentTime - lastFireTime > fireRate) {
                // Use raycasting from screen center (crosshair position)
                mouseVector.x = 0; // Center of screen (crosshair is always centered)
                mouseVector.y = 0;
                
                // Update raycaster with camera and crosshair position
                raycaster.setFromCamera(mouseVector, camera);
                
                // Shooting direction is exactly where crosshair points
                const shootDirection = raycaster.ray.direction.clone();
                shootDirection.normalize();
                
                // Create bullet at player position with accurate direction
                const bulletPosition = player.position.clone();
                bulletPosition.y += 1; // Shoot from chest height
                
                createBullet(bulletPosition, shootDirection, 'player');
                lastFireTime = currentTime;
            }
        }
        
        // Character Selection Functions
        function showCharacterSelection() {
            const characterGrid = document.getElementById('characterGrid');
            characterGrid.innerHTML = '';
            
            const characters = [
                { type: 'warrior', name: ' Warrior', health: 120, speed: 4, damage: 25, color: '#8B4513', ability: 'Shield Block' },
                { type: 'ninja', name: ' Ninja', health: 90, speed: 5, damage: 20, color: '#2F4F4F', ability: 'Invisibility' },
                { type: 'mage', name: ' Mage', health: 80, speed: 3, damage: 30, color: '#4B0082', ability: 'Fireball' },
                { type: 'robot', name: ' Robot', health: 150, speed: 3, damage: 25, color: '#708090', ability: 'Turret' },
                { type: 'alien', name: ' Alien', health: 100, speed: 4, damage: 20, color: '#00FF00', ability: 'Teleport' },
                { type: 'dragon', name: ' Dragon', health: 200, speed: 2, damage: 35, color: '#FFEB3B', ability: 'Flight' }
            ];
            
            characters.forEach(char => {
                const charDiv = document.createElement('div');
                charDiv.style.cssText = `
                    background: rgba(255,255,255,0.1);
                    border: 2px solid rgba(255,255,255,0.3);
                    border-radius: 10px;
                    padding: 15px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                `;
                charDiv.innerHTML = `
                    <h3>${char.name}</h3>
                    <div style="font-size: 12px; margin: 10px 0;">
                        <div> Health: ${char.health}</div>
                        <div> Speed: ${char.speed}</div>
                        <div> Damage: ${char.damage}</div>
                        <div> Ability: ${char.ability}</div>
                    </div>
                    <div style="width: 30px; height: 30px; background: ${char.color}; border-radius: 50%; margin: 0 auto; border: 2px solid #fff;"></div>
                `;
                
                charDiv.addEventListener('click', () => selectCharacter(char));
                charDiv.addEventListener('mouseenter', () => {
                    charDiv.style.background = 'rgba(255,255,255,0.2)';
                    charDiv.style.transform = 'scale(1.05)';
                });
                charDiv.addEventListener('mouseleave', () => {
                    charDiv.style.background = 'rgba(255,255,255,0.1)';
                    charDiv.style.transform = 'scale(1)';
                });
                
                characterGrid.appendChild(charDiv);
            });
            
            document.getElementById('characterSelection').style.display = 'block';
        }
        
        function hideCharacterSelection() {
            document.getElementById('characterSelection').style.display = 'none';
        }
        
        function selectCharacter(character) {
            // Map character type to ability
            const abilityMap = {
                'warrior': 'shield',
                'ninja': 'invisibility', 
                'mage': 'fireball',
                'robot': 'turret',
                'alien': 'teleport',
                'dragon': 'flight'
            };
            
            selectedCharacter = {
                health: character.health,
                speed: character.speed,
                damage: character.damage,
                color: parseInt(character.color.replace('#', '0x')),
                specialAbility: abilityMap[character.type] || 'none'
            };
            
            // Save to localStorage
            localStorage.setItem('selectedCharacter', JSON.stringify(selectedCharacter));
            
            // Update character info display
            const characterInfo = document.getElementById('characterInfo');
            characterInfo.textContent = `${character.name} - Health: ${character.health}, Speed: ${character.speed}, Damage: ${character.damage}, Ability: ${character.ability}`;
            
            // Hide character selection
            hideCharacterSelection();
            
            // If player already exists, recreate it with new character
            if (player && scene) {
                scene.remove(player);
                createPlayer();
            }
        }
        
        // Initialize the game when page loads
        window.addEventListener('load', function() {
            console.log('Page loaded, initializing 3D game...');
            init();
        });
    </script>
</body>
</html>
